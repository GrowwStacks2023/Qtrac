name: Deploy BriskLearning Infrastructure

on:
  push:
    paths:
      - 'deploy-trigger.txt'
    branches:
      - main
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - test  
        - prod
      deployment_version:
        description: 'Deployment version (v1, v2, v3, etc.)'
        required: false
        default: 'v1'
        type: string

env:
  ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
  ARM_CLIENT_SECRET: ${{ secrets.AZURE_CLIENT_SECRET }}
  ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
  ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}

jobs:
  detect-environment:
    runs-on: ubuntu-latest
    outputs:
      target-environment: ${{ steps.parse-trigger.outputs.environment }}
      should-deploy: ${{ steps.parse-trigger.outputs.should-deploy }}
      deployment-version: ${{ steps.parse-trigger.outputs.deployment-version }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Parse Trigger File or Manual Input
        id: parse-trigger
        run: |
          if [ "${{ github.event.inputs.environment }}" != "" ]; then
            echo "environment=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
            echo "deployment-version=${{ github.event.inputs.deployment_version || 'v1' }}" >> $GITHUB_OUTPUT
            echo "should-deploy=true" >> $GITHUB_OUTPUT
            echo "Manual deployment to ${{ github.event.inputs.environment }}"
          elif [ -f deploy-trigger.txt ]; then
            LATEST_LINE=$(grep -E "^(DEV|TEST|PROD):" deploy-trigger.txt | tail -n 1)
            if [ -n "$LATEST_LINE" ]; then
              TARGET_ENV=$(echo "$LATEST_LINE" | cut -d':' -f1 | tr '[:upper:]' '[:lower:]')
              echo "environment=$TARGET_ENV" >> $GITHUB_OUTPUT
              echo "deployment-version=v1" >> $GITHUB_OUTPUT
              echo "should-deploy=true" >> $GITHUB_OUTPUT
              echo "Deploying to $TARGET_ENV via trigger file"
            else
              echo "should-deploy=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "should-deploy=false" >> $GITHUB_OUTPUT
          fi

  deploy:
    needs: detect-environment
    runs-on: ubuntu-latest
    if: needs.detect-environment.outputs.should-deploy == 'true'
    environment: ${{ needs.detect-environment.outputs.target-environment }}
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git for State Management
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Create State Directory
        run: |
          mkdir -p terraform/state

      - name: Check for Existing State
        id: state_check
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          STATE_FILE="terraform/state/${ENV}.tfstate"
          if [ -f "$STATE_FILE" ]; then
            echo "existing_state=true" >> $GITHUB_OUTPUT
            echo "Found existing state for $ENV environment"
          else
            echo "existing_state=false" >> $GITHUB_OUTPUT
            echo "No existing state found - proceeding with fresh deployment"
          fi

      - name: Terraform Init
        working-directory: ./terraform
        run: terraform init

      - name: Load Existing State
        if: steps.state_check.outputs.existing_state == 'true'
        working-directory: ./terraform
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          cp "state/${ENV}.tfstate" terraform.tfstate
          echo "Loaded existing state from repository"

      - name: Terraform Plan
        working-directory: ./terraform
        env:
          TF_VAR_environment: ${{ needs.detect-environment.outputs.target-environment }}
          TF_VAR_deployment_version: ${{ needs.detect-environment.outputs.deployment-version }}
          TF_VAR_postgres_host: ${{ secrets.POSTGRES_HOST }}
          TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER }}
          TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          TF_VAR_postgres_database: ${{ secrets.POSTGRES_DATABASE }}
          TF_VAR_postgres_port: ${{ secrets.POSTGRES_PORT }}
          TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
          TF_VAR_ssl_email: ${{ secrets.SSL_EMAIL }}
          TF_VAR_vm_admin_password: ${{ secrets.VM_ADMIN_PASSWORD }}
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          
          echo "Planning deployment for $ENV environment (version $VERSION)..."
          terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./terraform
        env:
          TF_VAR_environment: ${{ needs.detect-environment.outputs.target-environment }}
          TF_VAR_deployment_version: ${{ needs.detect-environment.outputs.deployment-version }}
          TF_VAR_postgres_host: ${{ secrets.POSTGRES_HOST }}
          TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER }}
          TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          TF_VAR_postgres_database: ${{ secrets.POSTGRES_DATABASE }}
          TF_VAR_postgres_port: ${{ secrets.POSTGRES_PORT }}
          TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
          TF_VAR_ssl_email: ${{ secrets.SSL_EMAIL }}
          TF_VAR_vm_admin_password: ${{ secrets.VM_ADMIN_PASSWORD }}
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          echo "Applying infrastructure for $ENV environment..."
          terraform apply -auto-approve tfplan
          echo "Infrastructure deployed successfully"

      - name: Save State to Repository
        working-directory: ./terraform
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          STATE_FILE="state/${ENV}.tfstate"
          
          # Copy current state to repo
          cp terraform.tfstate "$STATE_FILE"
          
          # Add and commit state file
          git add "$STATE_FILE"
          git commit -m "Update Terraform state for $ENV environment [automated]" || echo "No state changes to commit"
          git push origin main
          
          echo "State saved to repository: $STATE_FILE"

      - name: Get Outputs
        id: terraform-outputs
        working-directory: ./terraform
        run: |
          echo "vm_public_ip=$(terraform output -raw vm_public_ip)" >> $GITHUB_OUTPUT
          echo "main_website_url=$(terraform output -raw main_website_url)" >> $GITHUB_OUTPUT
          echo "n8n_url=$(terraform output -raw n8n_url)" >> $GITHUB_OUTPUT

      - name: Display DNS Configuration
        run: |
          echo "## Deployment Complete!" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.detect-environment.outputs.target-environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Version:** ${{ needs.detect-environment.outputs.deployment-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**VM IP:** ${{ steps.terraform-outputs.outputs.vm_public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "**Domain:** ${{ secrets.DOMAIN_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### DNS Records to Configure:" >> $GITHUB_STEP_SUMMARY
          echo "Create these A records in your DNS provider:" >> $GITHUB_STEP_SUMMARY
          echo "- ${{ needs.detect-environment.outputs.target-environment }}.${{ secrets.DOMAIN_NAME }} → ${{ steps.terraform-outputs.outputs.vm_public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- n8n.${{ needs.detect-environment.outputs.target-environment }}.${{ secrets.DOMAIN_NAME }} → ${{ steps.terraform-outputs.outputs.vm_public_ip }}" >> $GITHUB_STEP_SUMMARY
          echo "- api.${{ needs.detect-environment.outputs.target-environment }}.${{ secrets.DOMAIN_NAME }} → ${{ steps.terraform-outputs.outputs.vm_public_ip }}" >> $GITHUB_STEP_SUMMARY

  cleanup-on-failure:
    needs: [detect-environment, deploy]
    runs-on: ubuntu-latest
    if: failure() && needs.detect-environment.outputs.should-deploy == 'true'
    
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Configure Git for State Management
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.5.0

      - name: Terraform Init for Cleanup
        working-directory: ./terraform
        run: terraform init

      - name: Load State for Cleanup (if exists)
        working-directory: ./terraform
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          STATE_FILE="state/${ENV}.tfstate"
          if [ -f "$STATE_FILE" ]; then
            cp "$STATE_FILE" terraform.tfstate
            echo "Loaded state for cleanup"
          else
            echo "No state file found for cleanup"
          fi

      - name: Terraform Destroy Failed Resources
        working-directory: ./terraform
        continue-on-error: true
        env:
          TF_VAR_environment: ${{ needs.detect-environment.outputs.target-environment }}
          TF_VAR_deployment_version: ${{ needs.detect-environment.outputs.deployment-version }}
          TF_VAR_postgres_host: ${{ secrets.POSTGRES_HOST }}
          TF_VAR_postgres_user: ${{ secrets.POSTGRES_USER }}
          TF_VAR_postgres_password: ${{ secrets.POSTGRES_PASSWORD }}
          TF_VAR_postgres_database: ${{ secrets.POSTGRES_DATABASE }}
          TF_VAR_postgres_port: ${{ secrets.POSTGRES_PORT }}
          TF_VAR_domain_name: ${{ secrets.DOMAIN_NAME }}
          TF_VAR_ssl_email: ${{ secrets.SSL_EMAIL }}
          TF_VAR_vm_admin_password: ${{ secrets.VM_ADMIN_PASSWORD }}
        run: |
          echo "Deployment failed. Running terraform destroy..."
          terraform destroy -auto-approve || echo "Terraform destroy completed with some errors"

      - name: Remove State File from Repository
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          STATE_FILE="terraform/state/${ENV}.tfstate"
          
          if [ -f "$STATE_FILE" ]; then
            git rm "$STATE_FILE"
            git commit -m "Remove Terraform state for $ENV environment after failed deployment cleanup [automated]" || echo "No state file to remove"
            git push origin main || echo "No state changes to push"
            echo "State file removed from repository"
          fi

      - name: Azure Login for Manual Cleanup
        run: |
          echo "Logging into Azure for manual cleanup..."
          az login --service-principal -u "$ARM_CLIENT_ID" -p "$ARM_CLIENT_SECRET" --tenant "$ARM_TENANT_ID"
          az account set --subscription "$ARM_SUBSCRIPTION_ID"
          az account show

      - name: Manual Cleanup - Phase 1 (VM and Dependencies)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 1: Cleaning up VMs and compute resources..."
          
          # Delete VMs first (this releases NIC associations)
          az vm delete --name "brisklearning-${ENV}-vm" --resource-group "$RG" --yes --no-wait || true
          az vm delete --name "bl${ENV}${VERSION}vm" --resource-group "$RG" --yes --no-wait || true
          
          echo "Waiting 30 seconds for VM deletion to process..."
          sleep 30

      - name: Manual Cleanup - Phase 2 (Network Interface Cards)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 2: Cleaning up Network Interface Cards..."
          
          # Delete NICs (this releases public IP associations)
          az network nic delete --name "brisklearning-${ENV}-vm-nic" --resource-group "$RG" --no-wait || true
          az network nic delete --name "bl${ENV}${VERSION}nic" --resource-group "$RG" --no-wait || true
          
          echo "Waiting 30 seconds for NIC deletion to process..."
          sleep 30

      - name: Manual Cleanup - Phase 3 (Public IPs and NSG Associations)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 3: Cleaning up Public IPs and NSG associations..."
          
          # Delete public IPs
          az network public-ip delete --name "brisklearning-${ENV}-vm-ip" --resource-group "$RG" || true
          az network public-ip delete --name "bl${ENV}${VERSION}ip" --resource-group "$RG" || true
          
          # Remove NSG associations from subnets
          SUBNET_ID="/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG/providers/Microsoft.Network/virtualNetworks/brisklearning-${ENV}-vnet/subnets/brisklearning-${ENV}-vm-subnet"
          az network vnet subnet update --ids "$SUBNET_ID" --network-security-group "" || true
          
          SUBNET_ID_V2="/subscriptions/$ARM_SUBSCRIPTION_ID/resourceGroups/$RG/providers/Microsoft.Network/virtualNetworks/bl${ENV}${VERSION}vnet/subnets/bl${ENV}${VERSION}subnet"
          az network vnet subnet update --ids "$SUBNET_ID_V2" --network-security-group "" || true
          
          echo "Waiting 30 seconds for NSG disassociation..."
          sleep 30

      - name: Manual Cleanup - Phase 4 (Network Security Groups)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 4: Cleaning up Network Security Groups..."
          
          # Delete NSGs (now that they're not associated)
          az network nsg delete --name "brisklearning-${ENV}-vm-nsg" --resource-group "$RG" || true
          az network nsg delete --name "bl${ENV}${VERSION}nsg" --resource-group "$RG" || true

      - name: Manual Cleanup - Phase 5 (Virtual Networks)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 5: Cleaning up Virtual Networks and Subnets..."
          
          # Delete subnets first, then VNets
          az network vnet subnet delete --name "brisklearning-${ENV}-vm-subnet" \
            --vnet-name "brisklearning-${ENV}-vnet" --resource-group "$RG" || true
          az network vnet subnet delete --name "bl${ENV}${VERSION}subnet" \
            --vnet-name "bl${ENV}${VERSION}vnet" --resource-group "$RG" || true
          
          az network vnet delete --name "brisklearning-${ENV}-vnet" --resource-group "$RG" || true
          az network vnet delete --name "bl${ENV}${VERSION}vnet" --resource-group "$RG" || true

      - name: Manual Cleanup - Phase 6 (Storage Accounts)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 6: Cleaning up Storage Accounts..."
          
          # Delete storage accounts (these also delete all containers)
          az storage account delete --name "bl${ENV}${VERSION}storage" --resource-group "$RG" --yes || true
          az storage account delete --name "brisklearning${ENV}storage" --resource-group "$RG" --yes || true
          az storage account delete --name "bltestv1storage" --resource-group "$RG" --yes || true

      - name: Manual Cleanup - Phase 7 (Key Vaults)
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Phase 7: Cleaning up Key Vaults..."
          
          # Delete Key Vaults
          az keyvault delete --name "bl${ENV}${VERSION}storage" --resource-group "$RG" || true
          az keyvault delete --name "brisklearning-${ENV}-kv" --resource-group "$RG" || true
          az keyvault delete --name "bltestv1storage" --resource-group "$RG" || true
          
          echo "Waiting 60 seconds before purging Key Vaults..."
          sleep 60
          
          # Purge Key Vaults (to free up names immediately)
          az keyvault purge --name "bl${ENV}${VERSION}storage" || true
          az keyvault purge --name "brisklearning-${ENV}-kv" || true
          az keyvault purge --name "bltestv1storage" || true

      - name: Cleanup Verification
        continue-on-error: true
        run: |
          ENV="${{ needs.detect-environment.outputs.target-environment }}"
          VERSION="${{ needs.detect-environment.outputs.deployment-version }}"
          RG="palash"
          
          echo "Verifying cleanup completion..."
          echo "Remaining resources in resource group:"
          az resource list --resource-group "$RG" --output table || true
          
          echo "Checking for soft-deleted Key Vaults:"
          az keyvault list-deleted --output table || true

      - name: Cleanup Summary
        run: |
          echo "## Cleanup Completed!" >> $GITHUB_STEP_SUMMARY
          echo "**Environment:** ${{ needs.detect-environment.outputs.target-environment }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deployment Version:** ${{ needs.detect-environment.outputs.deployment-version }}" >> $GITHUB_STEP_SUMMARY
          echo "**Cleanup Time:** $(date)" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** Deployment failed, cleaned up partial resources" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Cleanup Phases Completed:" >> $GITHUB_STEP_SUMMARY
          echo "1. Terraform destroy attempted" >> $GITHUB_STEP_SUMMARY
          echo "2. State file removed from repository" >> $GITHUB_STEP_SUMMARY
          echo "3. VMs and compute resources deleted" >> $GITHUB_STEP_SUMMARY
          echo "4. Network Interface Cards removed" >> $GITHUB_STEP_SUMMARY
          echo "5. Public IPs and NSG associations cleared" >> $GITHUB_STEP_SUMMARY
          echo "6. Network Security Groups deleted" >> $GITHUB_STEP_SUMMARY
          echo "7. Virtual Networks and subnets removed" >> $GITHUB_STEP_SUMMARY
          echo "8. Storage accounts deleted" >> $GITHUB_STEP_SUMMARY
          echo "9. Key Vaults deleted and purged" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Steps:" >> $GITHUB_STEP_SUMMARY
          echo "- Review deployment logs to identify the failure cause" >> $GITHUB_STEP_SUMMARY
          echo "- Consider using a different deployment version (e.g., v2, v3)" >> $GITHUB_STEP_SUMMARY
          echo "- All resources cleaned up, no ongoing Azure costs" >> $GITHUB_STEP_SUMMARY
          echo "- Resource names are freed up for reuse" >> $GITHUB_STEP_SUMMARY